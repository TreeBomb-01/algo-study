# 프렌즈4블록 풀이 로드맵 (문제 접근 가이드)

## 1) 문제 핵심 요약
- 보드에서 **같은 문자 2×2**가 생기면 **동시에** 지우고,
- 지운 뒤엔 **윗칸들이 아래로 떨어져** 빈칸을 채움(중력),
- 다시 2×2가 생기면 위 과정을 **반복**,
- 최종적으로 **지워진 블록의 총 개수**를 반환.

즉, **[탐색 → 마킹(동시 제거 표시) → 제거/카운트 → 중력]**을 **반복**하는 시뮬레이션 문제입니다.

---

## 2) 전체 알고리즘 (반복 루프)
1. **보드 자료구조 준비**: `list(str)` → `list(list[str])`로 바꾸면 수정이 쉬움. 빈칸은 `None`(또는 `0`, `'.'`) 등으로 관리.
2. **2×2 탐색 & 마킹**:  
   - 모든 (r, c)에 대해 `(r, c)`, `(r, c+1)`, `(r+1, c)`, `(r+1, c+1)`가 **같은 문자 & 빈칸 아님**이면 `mark[r][c] = True` 등으로 표시.
   - **여러 2×2가 겹치더라도 마킹만 하고 즉시 지우지 않기**(동시 제거 조건).
3. **제거 & 카운트**:  
   - `mark`가 `True`인 칸을 **전부** 지우며(빈칸으로), 이번 라운드에서 지워진 칸 수를 누적 카운트.
4. **중력(떨어뜨리기)**:  
   - **열(컬럼) 단위**로 처리: 위에서 아래로 보며 **빈칸이 아닌 문자를 아래쪽으로 모으고**, 위쪽은 빈칸으로 채움.
   - 구현 팁: `col = [grid[r][c] for r in range(m) if grid[r][c] is not None]` → 아래부터 채우고 나머지는 `None`으로.
5. **반복 종료 조건**:  
   - 이번 라운드에서 **아무 칸도 마킹되지 않았다면**(지워질 게 없다면) 종료.

---

## 3) 구현 팁
- **동시 제거**: 마킹 후 한 번에 제거해야 함. 발견 즉시 지우면 **연쇄 오탐** 발생.
- **빈칸 체크**: `None`/`'.'` 등 빈칸 표기가 비교에 끼지 않게 주의.
- **보드 경계**: 2×2를 보려면 `r ∈ [0..m-2]`, `c ∈ [0..n-2]` 범위만 스캔.
- **시간 복잡도**: 매 라운드 O(m·n) 탐색 + O(m·n) 중력. 최악에도 m, n ≤ 30이므로 충분.

---

## 4) 자주 하는 실수
- **중복 카운트**: 한 칸이 여러 2×2에 포함되어도 **한 번만** 지워져야 함 → 마킹 후 집계.
- **중력 순서**: 열마다 **아래에서 위로 채우기**(스택처럼). 위에서부터 채우면 꼬일 수 있음.
- **끝 조건**: 이번 라운드에 마킹 수가 0이면 반드시 빠져나오기.

---

## 5) 디버깅 루틴
- 매 라운드마다 보드 출력(작은 예제)으로 **마킹 → 제거 → 중력**이 제대로 작동하는지 시각 확인.
- `mark` 개수 카운트를 찍어 **무한 루프** 방지 체크.

---

## 6) 미니 예시 (직관 추적)
초기(예):  
```
TTTANT
RRFACC
RRRFCC
TRRRAA
TTMMMF
TMMTTJ
```
- 2×2 동일 블록들을 **동시에 마킹**
- **마킹된 칸 모두 제거** → 빈칸
- **열 단위 중력**으로 문자들이 아래로 내려와 빈칸 채움
- 새롭게 2×2가 생겼는지 **다시 탐색** … **반복**
- 지워진 칸 총합을 반환

---

## 7) 결론
- 이 문제는 고급 알고리즘이 아니라 **정확한 구현/시뮬레이션**이 핵심입니다.
- “마킹 → 동시 제거 → 중력”의 **세 단계를 확실히 분리**해 구현하면 안정적이고 디버깅도 쉽습니다.
