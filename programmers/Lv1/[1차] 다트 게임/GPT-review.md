# GPT-review: 다트 게임 문제 코드 리뷰

## 1) 전반 평가
- 사용자의 구현은 **문자 단위 파싱**으로 점수/보너스/옵션을 처리하며, 전반적으로 정상 동작합니다.  
- 특히 `#`, `*` 옵션 효과를 직전 라운드에 반영하려는 흐름은 문제 의도와 일치합니다.

다만, **경계 상황에서의 안전성**과 **가독성** 측면에서 개선 여지가 있습니다. 아래에 체크리스트와 정석 풀이를 함께 정리했습니다.

---

## 2) 현재 코드의 핵심 아이디어
- `score` 길이 3짜리 리스트에 각 라운드 점수를 저장
- `n` 포인터로 현재 라운드 인덱스를 관리
- `S/D/T`에서 제곱 처리, `*`는 현재/직전 두 배, `#`는 현재만 음수화
- `'10'`은 `'1'` 뒤에 `'0'`을 감지해 10점으로 세팅

---

## 3) 경계 케이스 체크리스트
- `*`가 **첫 라운드**에서 나올 때: 직전 라운드가 없으므로 **현재 점수만 두 배** 해야 함  
  → 이전 점수 접근 시 **인덱스 음수 접근**이 발생하지 않도록 `n >= 2` 조건 사용 권장
- 입력이 `'0'`으로 시작하는 경우(가능한 형식): `i==0`에서 `li[i-1]` 접근을 피하도록 **가드** 필요
- `'10'` 처리: `"1"` 다음 `"0"`만을 기준으로 잡을 때, 이미 저장된 `"1"`을 덮어씌우는 흐름은 유지되지만, **라운드 증가 타이밍**과의 상호작용이 헷갈릴 수 있음

> 현재 코드는 테스트에 통과했지만, 위와 같은 케이스에서 **잠재적 인덱스/흐름 실수** 가능성이 있으므로 방어적 코드가 바람직합니다.

---

## 4) 가독성을 높이는 정석 접근
가장 안전하고 읽기 쉬운 패턴은 **라운드 단위 토큰화**입니다.
1. **점수**(0~10) 읽기 → 숫자 2자리(`10`) 대비
2. **보너스**(`S/D/T`) 적용 → `x^1/x^2/x^3`
3. **옵션**이 있으면(`*`/`#`) 적용

이렇게 하면 **문자 단위 분기**(특히 `'10'` 처리, 보너스/옵션 순서)에서의 실수를 크게 줄일 수 있습니다.

---

## 5) 정석 풀이 (권장 구현)

```python
def solution(dartResult):
    scores = []
    i = 0
    n = len(dartResult)

    while i < n:
        # 1) 점수 (0~10)
        if i + 1 < n and dartResult[i].isdigit() and dartResult[i + 1] == '0':
            num = 10
            i += 2
        else:
            num = int(dartResult[i])
            i += 1

        # 2) 보너스 S/D/T
        bonus = dartResult[i]
        i += 1
        if bonus == 'S':
            val = num ** 1
        elif bonus == 'D':
            val = num ** 2
        else:  # 'T'
            val = num ** 3

        # 3) 옵션 (* or #) — 있을 수도/없을 수도
        if i < n and dartResult[i] in ('*', '#'):
            opt = dartResult[i]
            i += 1
            if opt == '*':
                val *= 2
                if scores:              # 직전 라운드가 있으면 두 배
                    scores[-1] *= 2
            else:  # '#'
                val *= -1

        scores.append(val)

    return sum(scores)
```

### 장점
- 숫자/보너스/옵션을 **라운드별 블록**으로 처리 → 흐름이 명확
- `*`의 직전 라운드 두 배는 **존재 여부 확인 후** 적용 → 인덱스 안전
- `'10'`을 자연스럽게 처리하므로 문자 단위 실수 가능성↓

---

## 6) 최소 수정 가이드 (사용자 코드 스타일 유지)

사용자 코드의 흐름을 유지하면서 안전성만 보완하려면 다음을 권장합니다.
- `*` 처리 시 직전 라운드 두 배는 `if n >= 2:`일 때만
- `'10'` 처리 시 `i > 0` 가드 추가

개념 예:
```python
if li[i] == '*':
    score[n-1] *= 2
    if n >= 2:
        score[n-2] *= 2

elif li[i] == '0' and i > 0 and li[i-1] == '1':
    score[n] = 10
```

---

## 7) 결론
- 현재 구현은 **정상 동작**하며 문제의 규칙을 충실히 반영합니다.
- 다만, **경계 상황에서의 안전성**과 **가독성**을 위해 라운드 단위 정석 풀이를 추천합니다.
- 실전 코딩테스트에서는 **가독성 높은 정석 풀이**가 디버깅 속도와 유지보수성을 크게 높여줍니다.
